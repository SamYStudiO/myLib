/* * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at  * *        http://www.mozilla.org/MPL/  * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the License.  * * The Original Code is myLib. * * The Initial Developer of the Original Code is * Samuel EMINET (aka SamYStudiO) contact@samystudio.net. * Portions created by the Initial Developer are Copyright (C) 2008-2011 * the Initial Developer. All Rights Reserved. * */package myLib.core{	import myLib.assets.Asset;	import myLib.assets.IAsset;	import myLib.assets.core;	import myLib.controls.skins.IFieldSkin;	import myLib.controls.skins.ISkin;	import myLib.displayUtils.AlignmentManager;	import myLib.displayUtils.AlignmentPoint;	import myLib.displayUtils.FocusGroup;	import myLib.displayUtils.USE_PIXEL_SNAPPING;	import myLib.events.ComponentEvent;	import myLib.form.IField;	import myLib.my_internal;	import myLib.styles.Padding;	import myLib.styles.StyleManager;	import myLib.utils.NumberUtils;	import myLib.utils.ObjectUtils;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Graphics;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.utils.getQualifiedClassName;	/**	 * Defines the value of the type property of a enabledChanged event object.	 * 	 * @eventType myLib.events.ComponentEvent.ENABLED_CHANGE	 */	[Event(name="enabledChanged", type="myLib.events.ComponentEvent")]	/**	 * Defines the value of the type property of a visibleChanged event object.	 * 	 * @eventType myLib.events.ComponentEvent.VISIBLE_CHANGE	 */	[Event(name="visibleChanged", type="myLib.events.ComponentEvent")]	/**	 * Defines the value of the type property of a move event object.	 * 	 * @eventType myLib.events.ComponentEvent.MOVE	 */	[Event(name="move", type="myLib.events.ComponentEvent")]	/**	 * Defines the value of the type property of a resize event object.	 * 	 * @eventType myLib.events.ComponentEvent.RESIZE	 */	[Event(name="resize", type="myLib.events.ComponentEvent")]	/**	 * Defines the value of the type property of a draw event object.	 * 	 * @eventType myLib.events.ComponentEvent.DRAW	 */	[Event(name="draw", type="myLib.events.ComponentEvent")]	/**	 * Defines the value of the type property of a enter event object.	 * Useful with text input components when component has focus and key enter is press.	 * 	 * @eventType myLib.events.ComponentEvent.ENTER	 */	[Event(name="enter", type="myLib.events.ComponentEvent")]	/**	 * AComponent is the abstract base class for all components.	 * 	 * @author SamYStudiO ( contact@samystudio.net )	 */	public class AComponent extends Asset implements IComponent	{		/**		 * @private		 */		protected var _skin : ISkin;		/**		 * @private		 */		protected var _style : Object;		/**		 * @private		 */		protected var _oldMouseEnabled : Boolean;		/**		 * @private		 */		protected var _oldMouseChildren : Boolean;		/**		 * @private		 */		protected var _isInitialized : Boolean;		/**		 * @private		 */		protected var _invalidation : Invalidation = new Invalidation();		/**		 * @private		 */		protected var _isLivePreview : Boolean;		/**		 * @private		 */		protected var _isFocused : Boolean;		/**		 * @private		 */		protected function get _defaultWidth() : Number		{			return 100;		}		/**		 * @private		 */		protected function get _defaultHeight() : Number		{			return 20;		}		/**		 * @inheritDoc		 */		public function get stageX() : Number		{			if ( stage == null ) return NaN;			var r : Rectangle = getRect( stage );			return r.x;		}		public function set stageX( x : Number ) : void		{			if ( stage == null ) return;			var r : Rectangle = getRect( stage );			move( x , r.y , null , stage );		}		/**		 * @inheritDoc		 */		public function get stageY() : Number		{			if ( stage == null ) return NaN;			var r : Rectangle = getRect( stage );			return r.y;		}		public function set stageY( y : Number ) : void		{			if ( stage == null ) return;			var r : Rectangle = getRect( stage );			move( r.x , y , null , stage );		}		/**		 * @inheritDoc		 */		public function get alignmentPoint() : String		{			return AlignmentPoint.TOP_LEFT;		}		public function set alignmentPoint( alignmentPoint : String ) : void		{			move( _x , _y , alignmentPoint );		}		/**		 * @private		 */		protected var _visible : Boolean = true;		/**		 * @inheritDoc		 */		public override function get visible() : Boolean		{			return _visible;		}		public override function set visible( b : Boolean ) : void		{			if ( _visible == b ) return;			_visible = super.visible = b;			dispatchEvent( new ComponentEvent( ComponentEvent.VISIBLE_CHANGED ) );		}		[Inspectable(defaultValue=true)]		/**		 * @inheritDoc		 */		public override function get useHandCursor() : Boolean		{			return super.useHandCursor;		}		public override function set useHandCursor( b : Boolean ) : void		{			if ( super.useHandCursor == b || ( _inspector && !_isLivePreview && !super.useHandCursor ) ) return;			super.useHandCursor = b;			var l : uint = numChildren;			for ( var i : uint = 0; i < l; i++ )			{				var o : DisplayObject = getChildAt( i );				if ( o is Sprite )					( o as Sprite ).useHandCursor = b;			}		}		[Inspectable(defaultValue=true)]		/**		 * @inheritDoc		 */		public override function get enabled() : Boolean		{			return super.enabled;		}		public override function set enabled( b : Boolean ) : void		{			if ( _enabled == b || ( _inspector && !_isLivePreview && !super.enabled ) ) return;			if ( !b )			{				_oldMouseEnabled = mouseEnabled;				_oldMouseChildren = mouseChildren;				_enabled = mouseEnabled = mouseChildren = false;			}			else			{				_enabled = true;				mouseEnabled = _oldMouseEnabled;				mouseChildren = _oldMouseChildren;			}			var l : uint = numChildren;			for ( var i : uint = 0; i < l; i++ )			{				var o : DisplayObject = getChildAt( i );				if ( o is IAsset )					( o as IAsset ).enabled = _enabled;			}			dispatchEvent( new ComponentEvent( ComponentEvent.ENABLED_CHANGED ) );		}		/**		 * @private		 */		protected var _minWidth : Number = 0;		/**		 * @inheritDoc		 */		public function get minWidth() : Number		{			return _minWidth;		}		public function set minWidth( mw : Number ) : void		{			_minWidth = mw;			if ( _width < _minWidth ) setSize( _width , _height );		}		/**		 * @private		 */		protected var _maxWidth : Number = Number.MAX_VALUE;		/**		 * @inheritDoc		 */		public function get maxWidth() : Number		{			return _minWidth;		}		public function set maxWidth( mw : Number ) : void		{			_maxWidth = mw;			if ( _width > _maxWidth ) setSize( _width , _height );		}		/**		 * @private		 */		protected var _minHeight : Number = 0;		/**		 * @inheritDoc		 */		public function get minHeight() : Number		{			return _minHeight;		}		public function set minHeight( mh : Number ) : void		{			_minHeight = mh;			if ( _height < _minHeight ) setSize( _width , _height );		}		/**		 * @private		 */		protected var _maxHeight : Number = Number.MAX_VALUE;		/**		 * @inheritDoc		 */		public function get maxHeight() : Number		{			return _maxHeight;		}		public function set maxHeight( mh : Number ) : void		{			_maxHeight = mh;			if ( _height > _maxHeight ) setSize( _width , _height );		}		/**		 * @private		 */		protected var _focusRectPadding : Padding = new Padding( 3 , 3 , 3 , 3 );		/**		 * @inheritDoc		 */		public function get focusRectPadding() : Padding		{			_focusRectPadding = _focusRectPadding == null ? new Padding( 3 , 3 , 3 , 3 ) : _focusRectPadding;			return _focusRectPadding;		}		public function set focusRectPadding( padding : Padding ) : void		{			_focusRectPadding = padding;			if ( _isFocused )			{				_isFocused = false;				drawFocus( true );			}		}		/**		 * @private		 */		protected var _focusRectTarget : IAsset;		/**		 * @inheritDoc		 */		public function get focusRectTarget() : IAsset		{			_focusRectTarget = _focusRectTarget == null ? this : _focusRectTarget;			return _focusRectTarget;		}		public function set focusRectTarget( asset : IAsset ) : void		{			_focusRectTarget = asset;			if ( _isFocused )			{				_isFocused = false;				drawFocus( true );			}		}		/**		 * @private		 */		protected var _focusRectDepth : int = 0;		/**		 * @inheritDoc		 */		public function get focusRectDepth() : int		{			return _focusRectDepth;		}		public function set focusRectDepth( n : int ) : void		{			_focusRectDepth = NumberUtils.clamp( n , -1 );			if ( _isFocused )			{				_isFocused = false;				drawFocus( true );			}		}		/**		 * @private		 */		protected var _inspector : Boolean;		/**		 * @private		 */		public function get componentInspectorSetting() : Boolean		{			return _inspector;		}		public function set componentInspectorSetting( b : Boolean ) : void		{			_inspector = b;		}		/**		 * @private		 */		protected var _focusRectAsset : IAsset;		/**		 * @inheritDoc		 */		public function get focusRectAsset() : IAsset		{			return _focusRectAsset;		}		/**		 * @private		 */		public function AComponent( parentContainer : DisplayObjectContainer = null , initStyle : Object = null , skin : ISkin = null )		{			if ( getQualifiedClassName( this ) == "myLib.core::AComponent" )				throw new Error( this + " Abstract class cannot be instantiated" );			_isLivePreview = _checkLivePreview();			_focusEnabled = true;			tabEnabled = true;			_skin = skin;			// move and size			var r : Number = rotation;			rotation = 0;			var w : Number = initStyle != null ? initStyle.width : NaN;			var h : Number = initStyle != null ? initStyle.height : NaN;			var x : Number = initStyle != null ? initStyle.x : NaN;			var y : Number = initStyle != null ? initStyle.y : NaN;			_originWidth = _defaultWidth;			_originHeight = _defaultHeight;			_width = isNaN( w ) ? core::width == 0 ? _defaultWidth : core::width : w;			_height = isNaN( h ) ? core::height == 0 ? _defaultHeight : core::height : h;			_x = isNaN( x ) ? core::x : x;			_y = isNaN( y ) ? core::y : y;			setSize( _width , _height );			move( _x , _y );			core::scaleX = core::scaleY = 1;			rotation = r;			// -------------			_removeChildren();			_createChildren();			_init();			var sm : StyleManager = StyleManager.getInstance();			sm.my_internal::registerInstance( this );			setStyle( ObjectUtils.merge( initStyle , skin != null ? skin.getStyle() : null , true ) );			my_internal::setClassStyle( sm.getClassStyle( this ) );			my_internal::setGlobalStyle( sm.getGlobalStyle() );			if ( this is IField )			{				if ( FocusGroup.DEFAULT_FOCUS_GROUP == null && stage != null ) _added();				else if ( FocusGroup.DEFAULT_FOCUS_GROUP != null ) FocusGroup.DEFAULT_FOCUS_GROUP.addItem( this );				addEventListener( Event.ADDED_TO_STAGE , _added , false , 9999999 , true );				addEventListener( Event.REMOVED_FROM_STAGE , _removed , false , 9999999 , true );			}			if ( parentContainer != null ) parentContainer.addChild( this );		}		/**		 * @inheritDoc		 */		public override function setSize( w : Number , h : Number ) : void		{			w = isNaN( w ) ? _width : Math.max( Math.min( _maxWidth , w ) , _minWidth );			h = isNaN( h ) ? _height : Math.max( Math.min( _maxHeight , h ) , _minHeight );			if ( _width == w && _height == h && _isInitialized ) return;			_width = w;			_height = h;			invalidate( InvalidationType.SIZE );			dispatchEvent( new ComponentEvent( ComponentEvent.RESIZE ) );		}		/**		 * @inheritDoc		 */		public override function move( x : Number , y : Number , alignmentPoint : String = "TL" , targetCoordinateSpace : DisplayObjectContainer = null ) : void		{			var p : Point = new Point( isNaN( x ) ? _x : x , isNaN( y ) ? _y : y );			if ( ( alignmentPoint != null && alignmentPoint != AlignmentPoint.TOP_LEFT ) || ( targetCoordinateSpace != null && targetCoordinateSpace != parent ) )			{				p = AlignmentManager.getAlignmentPoint( this , alignmentPoint == null ? AlignmentPoint.TOP_LEFT : alignmentPoint , targetCoordinateSpace , p.x , p.y );			}			if ( p.x == _x && p.y == _y && _isInitialized ) return;			_x = p.x;			_y = p.y;			core::x = USE_PIXEL_SNAPPING ? Math.round( _x ) : _x;			core::y = USE_PIXEL_SNAPPING ? Math.round( _y ) : _y;			dispatchEvent( new ComponentEvent( ComponentEvent.MOVE ) );		}		/**		 * @inheritDoc		 */		public function invalidate( types : uint = 7 ) : void		{			if ( _invalidation.contains( types ) ) return;			_invalidation.addTypes( types );			if ( stage == null ) addEventListener( Event.ADDED_TO_STAGE , _invalidate , false , 0 , true );			else _invalidate();		}		/**		 * @inheritDoc		 */		public override function draw() : void		{			if ( _invalidation.isActive() ) _render();		}		/**		 * @inheritDoc		 */		public function validate( types : uint = 7 ) : void		{			_invalidation.addTypes( types );			_render();		}		/**		 * @inheritDoc		 */		public function isInvalidate( ...types : Array ) : Boolean		{			if ( types.length == 0 ) return _invalidation.isActive();			else			{				var l : uint = types.length;				for ( var i : uint = 0; i < l; i++ )				{					if ( _invalidation.contains( types[ i ] ) ) return true;				}			}			return false;		}				/**		 * @inheritDoc		 */		public override function getBounds( targetCoordinateSpace : DisplayObject ) : Rectangle		{			var s : Shape;						if( numChildren == 0 )			{				s  = new Shape();				var g : Graphics = s.graphics;				g.drawRect( 0 , 0 , _width , _height );				addChild( s );			}						var r : Rectangle = super.getBounds( targetCoordinateSpace );			r.width = _width;			r.height = _height;						if( s != null) removeChild( s );						return r;		}				/**
		 * @inheritDoc
		 */
		public override function getRect( targetCoordinateSpace : DisplayObject ) : Rectangle
		{			var s : Shape;						if( numChildren == 0 )			{				s  = new Shape();				var g : Graphics = s.graphics;				g.drawRect( 0 , 0 , _width , _height );				addChild( s );			}			
			var r : Rectangle = super.getRect( targetCoordinateSpace );			r.width = _width;			r.height = _height;						if( s != null) removeChild( s );						return r;
		}		/**		 * @inheritDoc		 */		public function setStyle( style : Object ) : void		{			_style = style;			for ( var s : String in style )			{				if ( ObjectUtils.hasVariable( this , s ) ) this[ s ] = style[ s ];			}		}		/**		 * @inheritDoc		 */		public function getStyle() : Object		{			return _style;		}		/**		 * @inheritDoc		 */		public override function drawFocus( b : Boolean ) : void		{			if ( _isFocused == b || parent is AComponent ) return;			_isFocused = b;			if ( _focusRectAsset != null && contains( _focusRectAsset as DisplayObject ) )				removeChild( _focusRectAsset as DisplayObject );			_focusRectAsset = null;			if ( b && _skin is IFieldSkin )			{				_focusRectAsset = ( _skin as IFieldSkin ).getFocusRectAsset();				if ( _focusRectAsset != null )				{					var focusPadding : Padding = focusRectPadding;					var focusTarget : IAsset = focusRectTarget;					_focusRectAsset.x = ( focusTarget == this ? 0 : focusTarget.x ) - focusPadding.left;					_focusRectAsset.y = ( focusTarget == this ? 0 : focusTarget.y ) - focusPadding.top;					_focusRectAsset.setSize( focusTarget.width + focusPadding.left + focusPadding.right , focusTarget.height + focusPadding.top + focusPadding.bottom );					_focusRectAsset.draw();										if ( _focusRectDepth >= 0 ) addChildAt( _focusRectAsset  as DisplayObject , _focusRectDepth );					else addChild( _focusRectAsset  as DisplayObject );				}			}		}		/**		 * @private		 */		my_internal function setClassStyle( style : Object ) : void		{			ObjectUtils.merge( style , this , true , _style );		}		/**		 * @private		 */		my_internal function setGlobalStyle( style : Object ) : void		{			ObjectUtils.merge( style , this , true , ObjectUtils.merge( StyleManager.getInstance().getClassStyle( this ) , ObjectUtils.copy( _style ) ) );		}		/**		 * @private		 */		protected function _createChildren() : void		{		}		/**		 * @private		 */		protected function _removeChildren() : void		{			while ( numChildren > 0 ) removeChildAt( 0 );		}		/**		 * @private		 */		protected function _init() : void		{		}		/**		 * @private		 */		protected function _draw() : void		{		}		/**		 * @private		 */		protected function _checkLivePreview() : Boolean		{			if ( parent == null ) return false;			var className : String;			try			{				className = getQualifiedClassName( parent );			}			catch( e : Error )			{			}			return className == "fl.livepreview::LivePreviewParent";		}		/**		 * @private		 */		protected function _render( e : Event = null ) : void		{			if ( !_invalidation.isActive() ) return;			// TODO cannot remove listener at the moment > stage invalidate issue!			// removeEventListener( Event.RENDER , _render );			_draw();			if ( _isFocused )			{				_isFocused = false;				drawFocus( true );			}			_invalidation.removeAllTypes();			_isInitialized = true;			dispatchEvent( new ComponentEvent( ComponentEvent.DRAW ) );		}				/**		 * 		 */		private function _added( e : Event = null ) : void		{			if ( FocusGroup.DEFAULT_FOCUS_GROUP == null ) FocusGroup.DEFAULT_FOCUS_GROUP = new FocusGroup( "default" , stage );			var g : FocusGroup = FocusGroup.getGroupFromFocusable( this );			if ( g == null || g == FocusGroup.DEFAULT_FOCUS_GROUP ) FocusGroup.DEFAULT_FOCUS_GROUP.addItem( this );		}				/**		 * 		 */		private function _removed( e : Event = null ) : void		{			var g : FocusGroup = FocusGroup.getGroupFromFocusable( this );			if ( g != null && g == FocusGroup.DEFAULT_FOCUS_GROUP ) FocusGroup.DEFAULT_FOCUS_GROUP.removeItem( this );		}		/**		 *		 */		private function _invalidate( e : Event = null ) : void		{			if ( e != null ) removeEventListener( Event.ADDED_TO_STAGE , _invalidate );			addEventListener( Event.RENDER , _render , false , 0 , true );			stage.invalidate();		}	}}