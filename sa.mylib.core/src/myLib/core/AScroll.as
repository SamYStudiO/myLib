/* * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at  * *        http://www.mozilla.org/MPL/  * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the License.  * * The Original Code is myLib. * * The Initial Developer of the Original Code is * Samuel EMINET (aka SamYStudiO) contact@samystudio.net. * Portions created by the Initial Developer are Copyright (C) 2008-2011 * the Initial Developer. All Rights Reserved. * */package myLib.core{	import myLib.assets.core;	import myLib.controls.ScrollDirection;	import myLib.controls.skins.ISkin;	import myLib.displayUtils.AlignmentPoint;	import myLib.displayUtils.SizeManager;	import myLib.displayUtils.USE_PIXEL_SNAPPING;	import myLib.my_internal;	import myLib.transitions.Tween;	import myLib.utils.Timer;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.geom.Rectangle;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.utils.Dictionary;	import flash.utils.getQualifiedClassName;	
	use namespace my_internal;
	/**	 * Defines the value of the type property of a scroll event object.	 * 	 * @eventType scroll	 */    [Event(name="scroll", type="flash.events.Event")]    
	/**	 * AScroll is the abstract base class for all scroll components.	 * 	 * @author SamYStudiO	 */	public class AScroll extends AComponent implements IScroll	{			/**		 * @private		 */		protected static var __registeredTargets : Dictionary = new Dictionary( true );				/**		 * @private		 */		protected var _scrollTargetSize : Number;				/**		 * @private		 */		protected var _isScrollableTextField : Boolean;				/**		 * @private		 */		protected var _scrollPosition : Number = 0;				/**		 * @private		 */		protected var _scrollPositionPercentage : Number = 0;				/**		 * @private		 */		protected var _propSize : String = "height";				/**		 * @private		 */		protected var _lockPosition : Boolean;				/**		 * @private		 */		protected var _newWidth : Number;				/**		 * @private		 */		protected var _newHeight : Number;				/**		 * @private		 */		protected var _newX : Number;				/**		 * @private		 */		protected var _newY : Number;				/**		 * @private		 */		protected var _tween : Tween;				/**		 * @private		 */		protected var _timer : Timer = new Timer();				/**		 * @private		 */		protected var _scrollPositionPercentageOnVisible : Number = 0;				/**		 * @inheritDoc		 */		public function get scrollPositionPercentageOnVisible() : Number		{			return _scrollPositionPercentageOnVisible;		}				public function set scrollPositionPercentageOnVisible( n : Number ) : void		{			_scrollPositionPercentageOnVisible = n;		}				[Inspectable]		/**		 * @private		 */		public function get scrollTargetName() : String		{			return _scrollTarget.name;			}				public function set scrollTargetName( target : String ) : void		{			if( !_inspector && !_isLivePreview ) throw new Error( this + " scrollTargetName property is internal and used by Flash component inspector panel , use scrollTarget property to assign a DisplayObject" );						if( _inspector && !_isLivePreview && _scrollTarget != null ) return;						try			{				scrollTarget = parent.getChildByName( target );			}			catch ( e : Error )			{				throw new Error( this + " ScrollTarget named '" + target + "' not found" );			}		}				/**		 * @private		 */		protected var _scrollTarget : DisplayObject;					/**		 * @inheritDoc		 */		public function get scrollTarget () : DisplayObject		{			return _scrollTarget;		}				public function set scrollTarget( o : DisplayObject ) : void		{			if( o == _scrollTarget ) return;						if( _scrollTarget != null ) _removeRegisteredTarget( _scrollTarget );						if( o != null )			{				_registerTarget( o );			}						_scrollTarget = o;			_newWidth = NaN;			_newHeight = NaN;						invalidate( InvalidationType.SIZE | InvalidationType.DATA );		}				/**		 * @private		 */		protected var _horizontal : Boolean;		[Inspectable(defaultValue="vertical",enumeration="vertical,horizontal")]		/**		 * @inheritDoc		 */		public function get direction() : String		{			return _horizontal ? ScrollDirection.HORIZONTAL : ScrollDirection.VERTICAL;		}		public function set direction( s : String ) : void		{			if( s == direction || ( _isLivePreview && getQualifiedClassName( parent ) != "myLib.controls::ScrollPane" ) || ( _inspector && !_isLivePreview && _horizontal ) ) return;						_horizontal = s == ScrollDirection.HORIZONTAL;			_propSize = _horizontal ? "width" : "height";						if ( _horizontal && rotation == 0 )			{				rotation = -90;				core::scaleX = -1;				}			else if ( !_horizontal && rotation == -90 )			{				rotation = 0;				core::scaleX = 1;				}						if( _scrollTarget != null )				_registerTarget( _scrollTarget );		}				/**		 * @private		 */		protected var _scrollSize : Number = 20;		[Inspectable(defaultValue=20)]		/**		 * @inheritDoc		 */		public function get scrollSize() : Number		{			return _scrollSize;		}				public function set scrollSize( n : Number ) : void		{			if( !isNaN( _scrollSnap ) || ( _inspector && !_isLivePreview && _scrollSize != 20 ) ) return;						_scrollSize = n;		}				/**		 * @private		 */		protected var _scrollSnap : Number;				/**		 * @inheritDoc		 */		public function get scrollSnap() : Number		{			return _scrollSnap;		}				public function set scrollSnap( n : Number ) : void		{			if( _inspector && !_isLivePreview && !isNaN( _scrollSnap ) ) return;						_scrollSnap = n;			if( !isNaN( _scrollSnap ) ) _scrollSize = n;		}				/**		 * @private		 */		protected var _pageSize : Number;				/**		 * @inheritDoc		 */		public function get pageSize() : Number		{			return isNaN( _pageSize ) ? _height : _pageSize;		}		public function set pageSize( n : Number ) : void		{			if( _isScrollableTextField ) throw new Error( this + "Page size cannot be changed with scrollable textfield using pageSize property. To change page size with scrollable textfield use TextField.width or TextField.height properties and call update next" );						_pageSize = n;						invalidate( InvalidationType.DATA );		}				/**		 * @private		 */		protected var _useBitmapScrolling : Boolean;				[Inspectable(defaultValue=false)]		/**		 * @inheritDoc		 */		public function get useBitmapScrolling() : Boolean		{			return _useBitmapScrolling;		}				public function set useBitmapScrolling( b : Boolean ) : void		{			if( _inspector && !_isLivePreview && _useBitmapScrolling ) return;						_useBitmapScrolling = b;						if( _scrollTarget != null ) _scrollTarget.cacheAsBitmap = b;		}				/**		 * @private		 */		protected var _scrollTweenFunction : Function;				/**		 * @inheritDoc		 */		public function get scrollTweenFunction() : Function		{			return _scrollTweenFunction;		}				public function set scrollTweenFunction( easeFunction : Function ) : void		{			if( isNaN( _scrollTweenDuration ) ) _scrollTweenDuration = 500;						_scrollTweenFunction = easeFunction;		}				/**		 * @private		 */		protected var _scrollTweenDuration : Number = 500;				/**		 * @inheritDoc		 */		public function get scrollTweenDuration() : Number		{			return _scrollTweenDuration;		}				public function set scrollTweenDuration( n : Number ) : void		{			_scrollTweenDuration = n;		}				/**		 * @private		 */		protected var _maxScroll : Number;				/**		 * @inheritDoc		 */		public function get maxScroll() : Number		{			return _maxScroll;		}				/**		 * @private		 */		protected var _useful : Boolean;				/**		 * @inheritDoc		 */		public function get useful() : Boolean		{			return _useful;		}				/**		 * @inheritDoc		 */		public function get wrapTarget() : Boolean		{			return true;		}				/**		 * @private		 */		protected var _keyboardEnabled : Boolean = true;				[Inspectable(defaultValue=true)]		/**		 * @inheritDoc		 */		public function get keyboardEnabled() : Boolean		{			return _keyboardEnabled;		}				public function set keyboardEnabled( b : Boolean ) : void		{			if( _inspector && !_isLivePreview && !_keyboardEnabled ) return;						_keyboardEnabled = b;		}				/**		 * @inheritDoc		 */		public override function get width() : Number		{			return _horizontal ? _height : _width;		}				public override function set width( w : Number ) : void		{			super.width = w;		}				/**		 * @inheritDoc		 */		public override function get height() : Number		{			return _horizontal ? _width : _height;		}				public override function set height( h : Number ) : void		{			super.height = h;		}		/**		 * @private		 */		public function AScroll( parentContainer : DisplayObjectContainer = null , initStyle : Object = null , skin : ISkin = null )		{			super( parentContainer , initStyle , skin );						if( getQualifiedClassName( this ) == "myLib.core::AScroll" )				throw new Error( this + " Abstract class cannot be instantiated" );		}		/**		 * @inheritDoc		 */		public override function setSize( w : Number , h : Number ) : void		{			if( _horizontal ) super.setSize( h , w );			else super.setSize( w , h );						if( isNaN( _pageSize ) ) invalidate( InvalidationType.DATA );		}		/**		 * @inheritDoc		 */		public function update( lockPosition : Boolean = true , newWidth : Number = NaN , newHeight : Number = NaN ) : void		{			if( _scrollTarget == null ) return;						_lockPosition = lockPosition;			_newWidth = newWidth;			_newHeight = newHeight;			_isScrollableTextField = _scrollTarget is TextField && ( _scrollTarget as TextField ).autoSize == TextFieldAutoSize.NONE;						invalidate( InvalidationType.DATA );		}		/**		 * @inheritDoc		 */		public function scroll( amount : Number ) : Number		{			return _scroll( null , amount );		}				/**		 * @inheritDoc		 */		public function setScrollPosition( position : Number , percentage : Boolean = false ) : void		{			if( ( position == _scrollPosition && !percentage ||				position == _scrollPositionPercentage && percentage ) && _isInitialized ) return;							if( _isInitialized ) _tween.stop();						my_internal::_setScrollPosition( position , percentage );		}				/**		 * @inheritDoc		 */		public function getScrollPosition( percentage : Boolean = false ) : Number		{			return percentage ? _scrollPositionPercentage : _scrollPosition;		}				/**		 * @inherit		 */		public function tweenToPosition( position : Number , ease : Function = null , duration : Number = 500 , durationAsMilliseconds : Boolean = true ) : void		{			position = Math.max( 0 , Math.min( _maxScroll , position ) );						if( _tween.running )			{				_tween.setProp( _setScrollPosition , ease , _scrollPosition , position );				_tween.seek( 0 );				_tween.stop();			}			else _tween.addProp( _setScrollPosition , ease , _scrollPosition , position );						_tween.duration = duration;			_tween.durationAsMilliseconds = durationAsMilliseconds;			_tween.start( );		}				/**		 * @inheritDoc		 */		public function scrollToChild( child : DisplayObject , alignmentPoint : String = null ) : Boolean		{			var container : DisplayObjectContainer = _scrollTarget as DisplayObjectContainer;						if( container == null || child == null ) return false;						if( !container.contains( child ) ) return false;						var x : Number = child.x;			var y : Number = child.y;			var p : DisplayObjectContainer = child.parent;						while( p != container ) 			{				x += p.x;				y += p.y;								p = p.parent;			}						var pos : Number = _horizontal ? x : y;			var size : Number = _horizontal ? child.width : child.height;						switch( true )			{				case alignmentPoint == AlignmentPoint.TOP :					case alignmentPoint == AlignmentPoint.TOP_LEFT :					case alignmentPoint == AlignmentPoint.TOP_RIGHT && !_horizontal :					case alignmentPoint == AlignmentPoint.LEFT : setScrollPosition( pos ); break;									case alignmentPoint == AlignmentPoint.BOTTOM :					case alignmentPoint == AlignmentPoint.BOTTOM_LEFT && !_horizontal:					case alignmentPoint == AlignmentPoint.BOTTOM_RIGHT :					case alignmentPoint == AlignmentPoint.RIGHT : setScrollPosition( pos - ( pageSize - size ) ); break;									default : setScrollPosition( pos - ( pageSize - size ) / 2 ); break;				}						return true;		}				/**		 * @inheritDoc		 */		public function tweenToChild( child : DisplayObject , alignmentPoint : String = null , ease : Function = null , duration : Number = 500 , durationAsMilliseconds : Boolean = true ) : Boolean		{			var container : DisplayObjectContainer = _scrollTarget as DisplayObjectContainer;						if( container == null || child == null ) return false;						if( !container.contains( child ) ) return false;						var x : Number = child.x;			var y : Number = child.y;			var p : DisplayObjectContainer = child.parent;						while( p != container ) 			{				x += p.x;				y += p.y;								p = p.parent;			}						var pos : Number = _horizontal ? x : y;			var size : Number = _horizontal ? child.width : child.height;			var finish : Number;						switch( true )			{				case alignmentPoint == AlignmentPoint.TOP :					case alignmentPoint == AlignmentPoint.TOP_LEFT :					case alignmentPoint == AlignmentPoint.TOP_RIGHT && !_horizontal :					case alignmentPoint == AlignmentPoint.LEFT : finish = pos; break;									case alignmentPoint == AlignmentPoint.BOTTOM :					case alignmentPoint == AlignmentPoint.BOTTOM_LEFT && !_horizontal:					case alignmentPoint == AlignmentPoint.BOTTOM_RIGHT :					case alignmentPoint == AlignmentPoint.RIGHT : finish = pos - ( pageSize - size ); break;									default : finish = pos - ( pageSize - size ) / 2; break;				}						if( _tween == null ) _tween = new Tween( this );						if( _tween.running )			{				_tween.setProp( _setScrollPosition , ease , _scrollPosition , finish );				_tween.seek( 0 );			}			else _tween.addProp( _setScrollPosition , ease , _scrollPosition , finish );						_tween.duration = duration;			_tween.durationAsMilliseconds = durationAsMilliseconds;			_tween.start( );							return true;		}				/**		 * @private		 */		protected function _added( e : Event ) : void		{			_isLivePreview = _checkLivePreview();		}				/**		 * @private		 */		protected override function _init(  ) : void		{			_tween = new Tween( this );						_timer.addEventListener( TimerEvent.TIMER , _scroll );						addEventListener( Event.ADDED , _added, false , 0 , true );						_focusEnabled = false;		}
		/**		 * @private		 */		protected override function _draw(  ) : void		{			if( isInvalidate( InvalidationType.DATA ) )			{				_setScrollProperties( );				_invalidation.removeTypes( InvalidationType.DATA );			}						var wasVisible : Boolean = _visible;						visible = _useful = _isLivePreview ? true : pageSize < _scrollTargetSize && _scrollTarget != null;						if( _visible && !wasVisible )			{				_setScrollPosition( _scrollPositionPercentageOnVisible );				}			else			{				if( !_visible ) _scrollPosition = _scrollPositionPercentage = 0;								if( !_lockPosition ) _setScrollPosition( _scrollPositionPercentage , true );				else _setScrollPosition( _scrollPosition );								if ( !_visible && wasVisible && _scrollTarget != null ) _scrollTarget.scrollRect = null;			}		}				/**		 * @private		 */		protected function _scroll ( e : Event = null , size : Number = NaN ) : Number		{			return size;		}				/**		 * @private		 */		protected function _getOpScroll (  ) : IScroll		{			try			{				for ( var instance : * in __registeredTargets[ _scrollTarget ] )                 {					if( __registeredTargets[ _scrollTarget ][ instance ] == ( _horizontal ? ScrollDirection.VERTICAL : ScrollDirection.HORIZONTAL ) )					   return instance;				}			}			catch( e : Error )			{ 				return null;			}						return null;		}				/**		 * @private		 */		protected function _setScrollProperties () : void		{				if( _scrollTarget == null ) return;						if( _isScrollableTextField )			{				var tf : TextField = _scrollTarget as TextField;				_scrollTargetSize = _horizontal ? tf.maxScrollH + tf.width :  tf.bottomScrollV - tf.scrollV + tf.maxScrollV;				_pageSize = _horizontal ? tf.width : tf.bottomScrollV - tf.scrollV + 1;				_maxScroll = Math.max( 0 , _scrollTargetSize - _pageSize );								tf.mouseWheelEnabled = false;			}			else			{				var targetSize : Rectangle = SizeManager.getScrollTargetContentSize( _scrollTarget );								_newWidth = isNaN( _newWidth ) ? targetSize.width : _newWidth;				_newHeight = isNaN( _newHeight ) ? targetSize.height : _newHeight;								var size : Number = _horizontal ? _newWidth : _newHeight;								_scrollTargetSize = isNaN( size ) ? _scrollTarget[ _propSize ] : size;				_maxScroll = Math.max( 0 , _scrollTargetSize - pageSize );			}		}				/**		 * @private		 */		my_internal function _setScrollPosition( position : Number , percentage : Boolean = false ) : void		{			if( _scrollTarget == null || isNaN( _maxScroll ) ) return;			if( isNaN( position ) || position < 0 ) position = 0;			if( isInvalidate( InvalidationType.DATA ) ) _setScrollProperties( );						var old : Number = _scrollPosition;									if( percentage )			{				_scrollPositionPercentage = Math.min( Math.max( 0 , position ) , 100 );				_scrollPosition = Math.max( 0 , Math.min( _maxScroll , _maxScroll * _scrollPositionPercentage / 100 ) );				}			else			{				_scrollPosition = Math.min( Math.max( 0 , position ) , Math.max( 0 , _maxScroll ) );				_scrollPositionPercentage = Math.min( Math.max( 0 , _scrollPosition / _maxScroll * 100 ) , 100 );			}						if( isNaN( _scrollPosition ) ) _scrollPosition = 0;			if( isNaN( _scrollPositionPercentage ) ) _scrollPositionPercentage = 0;						if( _isScrollableTextField )			{				var tf : TextField = _scrollTarget as TextField;								if( !_horizontal )				{					_scrollPosition = Math.round( _scrollPosition );					tf.scrollV = _scrollPosition + 1;				}				else tf.scrollH = USE_PIXEL_SNAPPING ? Math.round( _scrollPosition ) : _scrollPosition;			}			else				{				var opScroll : IScroll = _getOpScroll();				var opScrollPosition : Number = opScroll == null ? 0 : opScroll.getScrollPosition();				var x : Number = _horizontal ? _scrollPosition : opScrollPosition;				var y : Number = _horizontal ? opScrollPosition : _scrollPosition;				var w : Number = _horizontal ? pageSize : opScroll == null ? _newWidth : opScroll.pageSize;				var h : Number = _horizontal ? opScroll == null ? _newHeight : opScroll.pageSize : pageSize;								x = USE_PIXEL_SNAPPING ? Math.round( x ) : x;				y = USE_PIXEL_SNAPPING ? Math.round( y ) : y;				w = USE_PIXEL_SNAPPING ? Math.round( w ) : w;				h = USE_PIXEL_SNAPPING ? Math.round( h ) : h;				_scrollTarget.scrollRect = new Rectangle( x , y , w , h );			}						if( old != _scrollPosition ) dispatchEvent( new Event( Event.SCROLL ) );		}				/**		 * @private		 */		protected function _registerTarget ( o : DisplayObject ) : void		{			var type : String = direction;							if( __registeredTargets[ o ] != undefined )			{				if( __registeredTargets[ o ][ this ] == type ) return;								for ( var instance : * in __registeredTargets[ o ] )                 {					if( __registeredTargets[ o ][ instance ] == type )					{						var scroll : IScroll = instance as IScroll;						scroll.scrollTarget = null;					}				}			}						if( __registeredTargets[ o ] == undefined )				__registeredTargets[ o ] = new Dictionary( true );						__registeredTargets[ o ][ this ] = type;						_isScrollableTextField = o is TextField && ( o as TextField ).autoSize == TextFieldAutoSize.NONE;						if( _isScrollableTextField )			{				var tf : TextField = o as TextField;								tf.addEventListener( Event.CHANGE , _textFieldChanged , false , 0 , true );			}			else			{				o.cacheAsBitmap = _useBitmapScrolling = _useBitmapScrolling || o.cacheAsBitmap;			}		}				/**		 * @private		 */		protected function _removeRegisteredTarget( o : DisplayObject ) : void		{			for ( var instance : * in __registeredTargets[ o ] )			{				if( __registeredTargets[ o ][ instance ] == direction )				{					delete __registeredTargets[ o ][ this ];				}			}						if( _getOpScroll() == null )			{				delete __registeredTargets[ o ];				o.scrollRect = null;								if( _isScrollableTextField )				{					var tf : TextField = o as TextField;					tf.removeEventListener( Event.CHANGE , _textFieldChanged );				}			}		}				/**		 * @private		 */		protected function _textFieldChanged( e : Event ) : void		{			invalidate( InvalidationType.DATA );		}				/**		 * @private		 */		protected override function _checkLivePreview(  ) : Boolean		{			if( parent == null ) return false;						var className : String;			var p : DisplayObjectContainer = parent;						while( p != null )			{				try { className = getQualifiedClassName( p ); }				catch( e : Error ) { }								if( className == "fl.livepreview::LivePreviewParent" ) return true;								p = p.parent;			}						return false;		}	}}